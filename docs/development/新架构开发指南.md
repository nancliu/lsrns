# 新架构开发指南

## 📋 概述

本指南面向开发团队，介绍如何在重构完成后的模块化架构下进行开发。新架构采用领域驱动设计，按业务功能组织代码，提供更好的开发体验和代码维护性。

**当前版本**: v0.65 - 分析功能完善，核心功能完全可用

## 🏗️ 架构原则

### 1. 领域驱动设计 (DDD)
- 按业务领域组织代码模块
- 每个模块有明确的业务边界
- 避免跨领域的强耦合

### 2. 分层架构
```
┌─────────────────┐
│   Routes Layer  │  ← API端点，请求响应处理
├─────────────────┤
│  Services Layer │  ← 业务逻辑，核心功能实现
├─────────────────┤
│   Models Layer  │  ← 数据模型，类型定义
├─────────────────┤
│   Shared Layer  │  ← 核心算法、工具函数、数据访问
└─────────────────┘
```

### 3. 依赖方向
- 上层依赖下层，下层不依赖上层
- Routes → Services → Models
- Services → Shared (utilities, data_access, analysis_tools)
- 避免循环依赖

## 🛠️ 开发环境设置

### 1. 项目结构理解

```
api/                    # API层 - 专注于接口和业务协调
├── main.py            # 唯一入口点
├── __init__.py        # 包初始化
├── services/          # 业务逻辑层
│   ├── __init__.py    # 对外统一接口
│   ├── base_service.py  # 基础服务类
│   └── *_service.py   # 具体业务服务
├── models/            # 数据模型层
│   ├── __init__.py    # 对外统一接口
│   ├── enums.py       # 枚举定义
│   ├── base.py        # 基础模型
│   ├── requests/      # 请求模型
│   ├── responses/     # 响应模型
│   └── entities/      # 实体模型
└── routes/            # API路由层
    ├── __init__.py    # 路由组织
    ├── middleware.py  # 公共中间件
    └── *_routes.py    # 分组路由

shared/                # 共享核心功能层
├── utilities/         # 通用工具函数
│   ├── __init__.py    # 工具函数统一接口
│   └── *_utils.py     # 分类工具函数
├── data_access/       # 数据访问层
│   ├── __init__.py    # 统一导出
│   └── *.py           # 数据访问相关功能
└── analysis_tools/    # 分析工具
    ├── __init__.py    # 统一导出
    └── *.py           # 分析相关功能
```

### 2. IDE配置

#### VS Code 配置示例

```json
// .vscode/settings.json
{
    "python.analysis.extraPaths": ["./"],
    "python.linting.enabled": true,
    "python.linting.pylintEnabled": true,
    "python.formatting.provider": "black",
    "python.formatting.blackArgs": ["--line-length", "100"],
    "files.exclude": {
        "**/__pycache__": true,
        "**/*.pyc": true
    }
}
```

#### PyCharm 配置
- 设置项目根目录为源码根目录
- 配置代码风格为 Black
- 启用类型检查

## 👨‍💻 开发工作流

### 1. 新功能开发流程

#### 步骤1: 确定功能归属
```python
# 问题：我要添加一个新的数据导出功能，应该放在哪里？

# 分析：
# - 这是数据处理相关功能 → api/services/data_service.py
# - 需要新的请求模型 → api/models/requests/data_requests.py  
# - 需要新的API端点 → api/routes/data_routes.py
# - 可能需要文件操作工具 → shared/utilities/file_utils.py
```

#### 步骤2: 模型定义
```python
# api/models/requests/data_requests.py
class DataExportRequest(BaseModel):
    case_id: str
    export_format: str = "csv"
    include_metadata: bool = True
    
    class Config:
        schema_extra = {
            "example": {
                "case_id": "case_20250119_143000",
                "export_format": "csv",
                "include_metadata": True
            }
        }
```

#### 步骤3: 服务实现
```python
# api/services/data_service.py
class DataService(BaseService):
    async def export_data(self, request: DataExportRequest) -> Dict[str, Any]:
        """导出案例数据"""
        try:
            # 1. 验证案例存在
            case_path = self._get_case_path(request.case_id)
            if not case_path.exists():
                raise ValueError(f"案例不存在: {request.case_id}")
            
            # 2. 调用共享工具进行导出
            from shared.utilities.file_utils import export_case_data
            result = export_case_data(case_path, request.export_format)
            
            # 3. 更新元数据
            self._update_export_history(request.case_id, result)
            
            return result
            
        except Exception as e:
            logger.error(f"数据导出失败: {e}")
            raise
```

#### 步骤4: 路由注册
```python
# api/routes/data_routes.py
@router.post("/export_data/", response_model=BaseResponse)
async def export_data(request: DataExportRequest):
    """导出案例数据"""
    try:
        data_service = DataService()
        result = await data_service.export_data(request)
        return create_success_response("数据导出成功", result)
    except Exception as e:
        return create_error_response(f"数据导出失败: {str(e)}")
```

### 2. 代码组织原则

#### 单一职责原则
```python
# ✅ 好的做法：每个类/函数只负责一件事
class CaseService(BaseService):
    def create_case(self, request: CreateCaseRequest) -> Case:
        """创建案例"""
        pass
    
    def get_case(self, case_id: str) -> Case:
        """获取案例"""
        pass

# ❌ 避免：一个类做太多事情
class CaseManager:
    def create_case(self): pass
    def get_case(self): pass
    def run_simulation(self): pass  # 这应该属于SimulationService
    def analyze_results(self): pass  # 这应该属于AnalysisService
```

#### 依赖注入
```python
# ✅ 好的做法：通过构造函数注入依赖
class AnalysisService(BaseService):
    def __init__(self, gantry_loader: GantryDataLoader = None):
        super().__init__()
        self.gantry_loader = gantry_loader or GantryDataLoader()
    
    async def analyze_accuracy(self, case_id: str) -> Dict[str, Any]:
        # 使用注入的依赖
        gantry_data = await self.gantry_loader.load_gantry_data(case_id)
        # ... 分析逻辑
```

### 3. 错误处理

#### 统一异常处理
```python
# api/routes/middleware.py
@handle_service_errors
async def api_endpoint(request):
    """统一的异常处理装饰器"""
    try:
        result = await service_function(request)
        return create_success_response("操作成功", result)
    except ValidationError as e:
        return create_error_response(f"参数验证失败: {str(e)}", status_code=400)
    except ValueError as e:
        return create_error_response(f"业务逻辑错误: {str(e)}", status_code=400)
    except Exception as e:
        logger.error(f"未预期的错误: {e}")
        return create_error_response("服务器内部错误", status_code=500)
```

#### 业务异常定义
```python
# api/models/exceptions.py
class CaseNotFoundError(ValueError):
    """案例不存在异常"""
    pass

class SimulationRunningError(RuntimeError):
    """仿真正在运行异常"""
    pass

class InvalidAnalysisDataError(ValueError):
    """分析数据无效异常"""
    pass
```

## 🔧 核心开发模式

### 1. 基础服务模式

```python
# api/services/base_service.py
class BaseService(ABC):
    """基础服务类，提供公共功能"""
    
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def load_metadata(self, file_path: Path) -> Dict[str, Any]:
        """加载元数据文件"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"加载元数据失败 {file_path}: {e}")
            return {}
    
    def save_metadata(self, file_path: Path, metadata: Dict[str, Any]):
        """保存元数据文件"""
        try:
            file_path.parent.mkdir(parents=True, exist_ok=True)
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(metadata, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.logger.error(f"保存元数据失败 {file_path}: {e}")
            raise
    
    def generate_unique_id(self, prefix: str = "item") -> str:
        """生成唯一ID"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        random_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=6))
        return f"{prefix}_{timestamp}_{random_suffix}"
```

### 2. 元数据管理模式

```python
# api/services/base_service.py
class MetadataManager:
    """元数据管理器，提供元数据操作功能"""
    
    @staticmethod
    def load_case_metadata(case_path: Path) -> Dict[str, Any]:
        """加载案例元数据"""
        metadata_file = case_path / "metadata.json"
        if metadata_file.exists():
            try:
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"加载案例元数据失败 {metadata_file}: {e}")
        return {}
    
    @staticmethod
    def update_simulations_index(case_path: Path, simulation_id: str, sim_metadata: dict):
        """更新仿真索引"""
        metadata_file = case_path / "metadata.json"
        metadata = MetadataManager.load_case_metadata(case_path)
        
        if "simulations" not in metadata:
            metadata["simulations"] = {}
        
        metadata["simulations"][simulation_id] = sim_metadata
        metadata["last_updated"] = datetime.now().isoformat()
        
        try:
            with open(metadata_file, 'w', encoding='utf-8') as f:
                json.dump(metadata, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"更新仿真索引失败 {metadata_file}: {e}")
            raise
```

### 3. 目录管理模式

```python
# api/services/base_service.py
class DirectoryManager:
    """目录管理器，提供目录结构管理功能"""
    
    @staticmethod
    def create_case_structure(case_path: Path, case_name: str) -> Dict[str, Path]:
        """创建案例目录结构"""
        directories = {
            "config": case_path / "config",
            "simulations": case_path / "simulations",
            "analysis": case_path / "analysis",
            "outputs": case_path / "outputs",
            "logs": case_path / "logs"
        }
        
        for dir_path in directories.values():
            dir_path.mkdir(parents=True, exist_ok=True)
        
        return directories
    
    @staticmethod
    def create_simulation_structure(sim_path: Path, sim_type: str) -> Dict[str, Path]:
        """创建仿真目录结构"""
        directories = {
            "config": sim_path / "config",
            "outputs": sim_path / "outputs",
            "logs": sim_path / "logs"
        }
        
        # 根据仿真类型创建特定目录
        if sim_type == "microscopic":
            directories["e1_detectors"] = sim_path / "e1_detectors"
        elif sim_type == "mesoscopic":
            directories["summary"] = sim_path / "summary"
        
        for dir_path in directories.values():
            dir_path.mkdir(parents=True, exist_ok=True)
        
        return directories
```

## 🧪 测试策略

### 1. 单元测试

```python
# tests/test_data_service.py
import pytest
from unittest.mock import Mock, patch
from api.services.data_service import DataService
from api.models.requests.data_requests import TimeRangeRequest

class TestDataService:
    def setup_method(self):
        self.service = DataService()
    
    def test_process_od_data_success(self):
        """测试OD数据处理成功场景"""
        request = TimeRangeRequest(
            start_time="2025/07/21 08:00:00",
            end_time="2025/07/21 09:00:00",
            case_name="测试案例"
        )
        
        with patch('shared.data_access.od_table_resolver.get_table_names_from_date') as mock_resolver:
            mock_resolver.return_value = ["dwd_20250721"]
            
            result = self.service.process_od_data(request)
            
            assert result["success"] is True
            assert "case_id" in result["data"]
            assert result["data"]["status"] == "completed"
    
    def test_process_od_data_invalid_time_range(self):
        """测试无效时间范围场景"""
        request = TimeRangeRequest(
            start_time="2025/07/21 09:00:00",
            end_time="2025/07/21 08:00:00",  # 结束时间早于开始时间
            case_name="测试案例"
        )
        
        with pytest.raises(ValueError, match="结束时间必须晚于开始时间"):
            self.service.process_od_data(request)
```

### 2. 集成测试

```python
# tests/test_integration.py
import pytest
from fastapi.testclient import TestClient
from api.main import app

client = TestClient(app)

class TestIntegration:
    def test_full_workflow(self):
        """测试完整工作流程"""
        # 1. 创建案例
        case_response = client.post("/api/v1/case/create_case/", json={
            "case_name": "集成测试案例",
            "description": "测试完整工作流程"
        })
        assert case_response.status_code == 200
        case_id = case_response.json()["data"]["case_id"]
        
        # 2. 处理OD数据
        od_response = client.post("/api/v1/data/process_od_data/", json={
            "start_time": "2025/07/21 08:00:00",
            "end_time": "2025/07/21 09:00:00",
            "case_name": "集成测试案例"
        })
        assert od_response.status_code == 200
        
        # 3. 运行仿真
        sim_response = client.post("/api/v1/simulation/run_simulation/", json={
            "case_id": case_id,
            "simulation_type": "microscopic"
        })
        assert sim_response.status_code == 200
        
        # 4. 检查结果
        case_detail = client.get(f"/api/v1/case/case_detail/{case_id}")
        assert case_detail.status_code == 200
        assert case_detail.json()["data"]["status"] == "completed"
```

## 📚 最佳实践

### 1. 代码风格

#### 命名规范
```python
# ✅ 好的命名
class DataService:           # 类名使用PascalCase
    def process_od_data():   # 方法名使用snake_case
        pass

# 变量命名
case_id = "case_20250119_143000"    # 使用下划线分隔
simulation_type = "microscopic"     # 描述性命名

# ❌ 避免的命名
class dataservice:           # 类名应该大写
    def ProcessODData():     # 方法名应该小写
        pass

# 变量命名
c = "case_20250119_143000"  # 单字母变量名
st = "microscopic"          # 缩写不清晰
```

#### 文档字符串
```python
def process_od_data(
    start_time: str,
    end_time: str,
    case_name: str,
    **kwargs
) -> Dict[str, Any]:
    """
    处理OD数据并创建案例
    
    Args:
        start_time: 开始时间，格式：YYYY/MM/DD HH:MM:SS
        end_time: 结束时间，格式：YYYY/MM/DD HH:MM:SS
        case_name: 案例名称
        **kwargs: 其他参数
        
    Returns:
        包含处理结果的字典
        
    Raises:
        ValueError: 时间格式无效或时间范围错误
        RuntimeError: 数据处理失败
        
    Example:
        >>> result = process_od_data(
        ...     start_time="2025/07/21 08:00:00",
        ...     end_time="2025/07/21 09:00:00",
        ...     case_name="测试案例"
        ... )
        >>> print(result["case_id"])
        case_20250119_143000
    """
    pass
```

### 2. 性能优化

#### 异步处理
```python
# ✅ 好的做法：使用异步处理
async def process_multiple_cases(case_ids: List[str]) -> List[Dict[str, Any]]:
    """并发处理多个案例"""
    tasks = [process_single_case(case_id) for case_id in case_ids]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return results

# ❌ 避免：同步处理
def process_multiple_cases_sync(case_ids: List[str]) -> List[Dict[str, Any]]:
    """同步处理多个案例（性能较差）"""
    results = []
    for case_id in case_ids:
        result = process_single_case_sync(case_id)
        results.append(result)
    return results
```

#### 缓存机制
```python
from functools import lru_cache

class DataService(BaseService):
    @lru_cache(maxsize=128)
    def get_table_names_from_date(self, date_str: str) -> List[str]:
        """缓存表名查询结果"""
        return get_table_names_from_date(date_str)
```

### 3. 错误处理

#### 优雅降级
```python
async def analyze_accuracy(self, case_id: str) -> Dict[str, Any]:
    """分析精度，支持优雅降级"""
    try:
        # 尝试完整分析
        return await self._full_accuracy_analysis(case_id)
    except Exception as e:
        logger.warning(f"完整分析失败，尝试基础分析: {e}")
        
        try:
            # 降级到基础分析
            return await self._basic_accuracy_analysis(case_id)
        except Exception as e2:
            logger.error(f"基础分析也失败: {e2}")
            # 返回错误信息，但不中断程序
            return {
                "success": False,
                "error": f"分析失败: {str(e2)}",
                "fallback_available": False
            }
```

## 🚀 部署和运维

### 1. 环境配置

```python
# shared/utilities/config_utils.py
import os
from typing import Optional

def get_env_config(key: str, default: Optional[str] = None) -> str:
    """获取环境配置"""
    value = os.getenv(key, default)
    if value is None:
        raise ValueError(f"必需的环境变量未设置: {key}")
    return value

# 配置示例
DATABASE_URL = get_env_config("DATABASE_URL")
API_HOST = get_env_config("API_HOST", "0.0.0.0")
API_PORT = int(get_env_config("API_PORT", "8000"))
DEBUG = get_env_config("DEBUG", "false").lower() == "true"
```

### 2. 日志配置

```python
# shared/utilities/logging_utils.py
import logging
import sys
from pathlib import Path

def setup_logging(
    log_level: str = "INFO",
    log_file: Optional[Path] = None,
    log_format: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
):
    """设置日志配置"""
    # 设置根日志级别
    logging.basicConfig(
        level=getattr(logging, log_level.upper()),
        format=log_format,
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )
    
    # 如果指定了日志文件，添加文件处理器
    if log_file:
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(logging.Formatter(log_format))
        logging.getLogger().addHandler(file_handler)
    
    # 设置第三方库的日志级别
    logging.getLogger("uvicorn").setLevel(logging.INFO)
    logging.getLogger("fastapi").setLevel(logging.INFO)
```

## 📚 相关资源

### 1. 官方文档
- [FastAPI官方文档](https://fastapi.tiangolo.com/)
- [Pydantic官方文档](https://pydantic-docs.helpmanual.io/)
- [Python异步编程](https://docs.python.org/3/library/asyncio.html)

### 2. 项目文档
- [架构重构完成报告](架构重构完成报告.md)
- [新架构API指南](../api_docs/新架构API指南.md)
- [门架数据管理说明](门架数据管理说明.md)

### 3. 开发工具
- [Black代码格式化](https://black.readthedocs.io/)
- [Pylint代码检查](https://www.pylint.org/)
- [Pytest测试框架](https://docs.pytest.org/)

## 🔄 更新日志

### v2.0.0 (2025-01-19)
- ✅ 完成架构重构
- ✅ 实现完全模块化设计
- ✅ 移除向后兼容性
- ✅ 优化开发体验
- ✅ 完善测试策略
- ✅ 更新开发指南

---

*最后更新: 2025年1月19日*
